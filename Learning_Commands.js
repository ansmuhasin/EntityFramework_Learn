//https://docs.microsoft.com/en-us/ef/ef6/
//! 3 Types
//+ DAtabase first, Code first, model first
//+ DataBase First - We design our tables, EF creates domain classes
//+ Code First - We create our domain classes, EF creates database tables.
//+ model First - We use visual designer , EF will generate domain classes and DB

//! Database first
//+ Add the entity framework referance, then add a new item ADO.net data model. give name and then select the connection string and select the table details that we need to create the table.
//+ so it will generate some auto generated code for us. there will be a designer, inside that a template files will be there.
//+ there will be a context model which is inheriting from DbContext. and a connection string will be passed. also the class contains the dbset of the table we selected.
//+ and the class for the table will also be created.

//* This entire autogenerated code and the diagrams can be removed. we just need a context class which inheriting from the DbContext. and we can pass a normal connection
//* string. And we can create a normal model class for the table by giving the attribute [table("tablename")] and mentioning the Key column using attribute [Key].
//* and the same table class can be used inside the context class as DBset. after that we can do the same operation. we can delete all the autogenerated code.
//* we can do all the work manually and it is more clean. we can use our own connection string, we can create a context class which os inheriting DbContext.
//* and we can create a table class and use it in the dbset.
//% if we use key attribute, by default it will consider as identity. so if the actual column is not identity, we need to explicitly tell. we can do that by adding another 
//% attribute [DatabaseGenerated(DatabaseGeneratedOption.None)]
//https://www.entityframeworktutorial.net/code-first/databasegenerated-dataannotations-attribute.aspx
//* public partial class DBContextForLearningDB : DbContext
//* {
//*     public DBContextForLearningDB(string connectionString)
//*         : base(connectionString)
//*     {
//*     }
//*     public virtual DbSet<Employee> Employees { get; set; }
//* }

//* [Table("tblEmployee")]
//* public class Employee
//* {
//*     [DatabaseGenerated(DatabaseGeneratedOption.None)]
//*     [Key]
//*     public int EmployeeNumber { get; set; }
//*     public string EmployeeFirstName { get; set; }
//* }

//* string connectionString = new SqlConnectionStringBuilder(ConfigurationManager.ConnectionStrings["Learning_DBConnection"].ConnectionString).ConnectionString;
//* DBContextForLearningDB entity = new DBContextForLearningDB(connectionString);
//* Employee employee = new Employee
//* { DateOfBirth = new DateTime(),
//*     Department = "Payroll",
//*     EmployeeFirstName = "Ans",
//*     EmployeeNumber = 103
//* };
//* entity.Employees.Add(employee);
//* entity.SaveChanges();

//! Codefirst method.
//+ we create the table class.and we create a db context class with dbsets of created class, and mention the connection string in web.config.
//+ we need to enable code first migration PM> enable-migrations
//+ these steps we do only once
//+ every time we make changes to the model, we need to create a migration and give a name PM> add-migration Createpost
//+ it will create 2 new files for the migration
//+ after that we need to write, PM> update database
//+ this will do the changes in DB

//! DB First Approach
//+ right click solution and add a item, select ADO.Net entity data model, EF designer from DB, connection string, next next, pluraalize checkmark will help to
//+ automatically give names to classes. students to student for the one class.\
//+ now we can see the diagram, right click on the empty area and we can see some custamization. To rename a entity, right click and go to property
//+ every time we make changes to the entity model, it will make changes to the autogenerated codes, it can break some existing code
//+ navigation property will help to navigate the entity to another. EF supports all kind of relationships

//! EDMX Enitity data model
//+ edmx designer is a xml file used for visual representaion. close the edmx to open the xml viewer right click on the edmx file and open with xml, 2 section runtime
//+ and designer. designer section includes the visual rep of the designer. runtime is related everything related to model. storage model represends details of the 
//+ DB. conceptual model represents the details of the model classes. and mapping represents the mapping between those.
//+ storage model knows about the database schema. 
//+ conceptual model knows about the model classes. Mpaaing will mapp these two models
//+ for mapping, we can select the entity from the diagram we can right click and select table mapping. we can change the mapping.
//+ storage model visual representation.right click on the empty area and click model browser. we can see the table details in the store.

//! Connection string
//+ in config file, we have a connection string created by the ef. metadata include 3 resource. and the connection string. metadata repersents the xml of our storage 
//+ conceptiol nd mapping. when compile application, this model will convert to assembly in metadata and these resoures are used here.

//! Making changes to the DB.
//+ Add the table in the db. and come to the data model diagram, right click on the empty space and select update model from datatbase. In add tab, select what we 
//+ wants to newly add. Items which i not there in our entity model.
//+ refresh represents the entity we will refresh and, delete will represent what we need to delete. After clicking finish, new table will be dded to the model
//+ Update a table, rename a cloumn, add a column and delete a column. rename will be automatically taken care of. but fo renaming, it actually create one more 
//+ property in the model, and keep the old one there. so we manually need to delete it. and fix the all the errors which is already using that property. 
//+ same for deleteing a column. it will not delete the propert from the model but the mapping will be deleted.
//+ type change as well, we might need to manually need to convert.
//+ delete a table, select delete tab and sinish. after that we need to manually delete it.
//+ for adding something to the table is easy, but if we update and delete it, we need to do manual mapping.
//! Stored procudure
//+ we can add new sp o the model using update model. select the sp and add it to the model. if we select the last checkbox "import SP into entity model", 
//+ it will create a method for us that we can call.
//+ we can see the functions in function imports
//+ this method and functions will be available in dbcontext. we can use em.
//+ PlutoDBContext plutoDBContext = new PlutoDBContext();
//* ObjectResult<GetCourses_Result> GetCourses_Results = plutoDBContext.GetCourses();
//* foreach (GetCourses_Result item in GetCourses_Results)
//* {
//*     Console.WriteLine(item.Description);
//* }
//* Console.ReadLine();

//+ we can go to the model browser and we can change mapping and naming and return type of the functions and sp by clicking on the function.
//+ return type can be changed and we can auto generate it from the window.

//! Using enums in entity data model
//+ In model browser, click enum types and add. go to the model diagram and select the property of the column and then change the type
//+ If we already have a enum and if we need to use it, we can create it in the code and open the add enum window  and give exactly the same names and 
//+ then referance external enum

//! Code first workflow
//+install EF first. for that open package manager console and run install-package EntityFramework
//+ create proper entity classes and then create a dbcontext. create dbset. dbset is a collection of objects that represents a table in db.
//+ Create a connection string manually, and pass this connection string to the base of the dbcontext "name=ConnectionName"
//+ write commant in package console PM> enable-migration, After succeed, run command add-migration SomeName. migration folder will be created
//+ table method will try to create a table in the db
//+ run PM update-database . this will create the tables in the datatabase

//! Code first with existing database
//+ select the project and add item, select the ado.net entity datta model and give a name. we need to select code first from database. specify the connection string
//+ select the table contents to import. migrationhistory is a table used by entity framework. we can desect that table so that it will not create any model class
//+ It will create some files, model classes and context. go to package manager console and enable-migrations. add-migration SomeName. if we try to update the database,
//+ it will create an exception, so we are going to force ignore changes(we are telling the migrations that these chnages are already existing). 
//+ add-migration SomeName -IgnoreChanges -Force . It will create an empty migration . update-datatbase

//! Adding new classes
//+ Create a new class and give properties.example Id and name. Id or classnameId is the general conventions that entity framework will understand.
//+  if we want to give different names then there are other steps. then add migrations. always better to add small migrations. bigger changes can cause lot of errors.
//+ while adding migration we can give 2 types of names. model centric and database centric. better to give database centric names.
//+ add the class to  the dbcontext and then add-migration AddSomeTable. entity framework will create migrations. 
//+ if we already have a migration, and if we want to use the same name then we need to use force command for overriding the same migations. 
//+ in the migrations if we want we can change the identity to false. also we can use a method Sql() to run any sql statement in the database.
Sql("Insert ino Categories values (1, 'Web Development')"); //+ Run the mgrations update-DataBase
//+ we can add the a new property of newly added model in existing table model. //+ public Category Category { get; set; }
//+ then add migrations. so the migrations will create the column index and foreign key. update the database.
//+ Add another column, nullable datetime and add to migration. Rename one model property and again update the tables. This will actually delete the column and add new column
//+ this can leads to data loss. so we need to hndle it, there are 2 ways. 
//+ 1, RanameColumn("dbo.Cources", "Title" , "Name");     2. using Sql() method. move the data using sql statement. Sql("Update Courses set name = title");
//+ Do the proper changes in down as well(reverse of up).
//+ Delete a property from the model class and add the migrations. and run it . coolumn will be deleted.

//! Deleting the model
//+ first delete the referance of the class from other models and add the migrations and run it. then delete the model and then delete the dbset. build the project and
//+ add migration and run it.
//% But this will delete the table as well as the data. for that reason, we can create another bsckup table using Sql method or helper method and move the data to the backup table.
//+ we can copy the code from the down()method for creating the new table. for shortcut. then ew can write Sql() method to move the data. change the down method as well
//* CreateTable(
//*     "dbo._Categories",
//*     c => new
//*     {
//*         CategoryID = c.Int(nullable: false, identity: true),
//*         Name = c.String(),
//*     })
//*     .PrimaryKey(t => t.CategoryID);
//* Sql("Insert into _Categories (Name) Select Name From Categories");
//* DropTable("dbo.Categories");

//! Making mistakes and recovering
//+ If we make any mistakes and done a migration in the past. we cannot go and delete it. it will create a lot of problems in the future.
//+ Migrations are forward only, if we make any mistake, we need to create another migration to make up for it.

//! Downgrading to a older vertion of the database
//+ 1. Checkout the older vertion and run the migrations to a empty database with new connection string
//+ 2. we can go back to older migration using update-database -TargetMigration:F . This will bring backthr db to the specific version we want.
//+ _MigrationHistory will contain the events happened to the migrations
//* update-database -TargetMigration RemovedDatePublishedColumnFromCoursesTsble
//+ To bring it back, we can run update-database again

//! Configuration class
//+ Created by entity framework. Seed method can be used to seed the data to the DB. after the migration ran, it wwill run the seed data.update or add the data.
//* protected override void Seed(CodeFirstWithoutDataBase.PlutoContext context)
//* {
//*     context.Authors.AddOrUpdate(a => a.Name,
//*     new Author
//*     {
//*         Name = "Ans",
//*         Courses = new List<Course> { new Course { Name = "Javascript", Description = "Beginner Javascript" } }
//*     });
//* }

//! overriding conventions
//+ Entity framework code first is conventions over configuration, which means we can reduce the configurations but conventions will take care of it.
//+ To overriding conventions there are 2 ways, 1. Data annotations 2. fluent API
//+ when we create a column using code first ang give it as string, it will create nvarchar(Max) nullable by deafult. because string  in C# is nullable.
//+ we can add a attribute [Required] for making the column non nullable for a column
//* [Required]
//* public string Description { get; set; }
//% Doing it using Fluent API
//+ When we go to pluto context we can see the a method OnModelCreating. we can modify it for changing the conventions.
//* modelBuilder.Entity<Course>().Property(p => p.Description).IsRequired();
//+ after adding the migrations, we got the same migration as previous..

//! Data Annotations.
[Table("tblCourses")]  //+ For explicitly mentioning the table namae, by default entity framework  will consider the model name as the table name.
[Table("tblCourses", Schema = "Catalog")] //+ By default the schema is dbo, if we want to mention deferrent schema, we need to mention like this.
[Column("sName")]  //+ By default, properties considered as the column name and if we want to give different name to the property, we can mention the column name like this.
[Column("sName", type = "varchar")]  //+ if we want to give a different DB type wecan mention it like this.
//% If we have a ID column or ClassnameID Property, EF will assume that the column is the primery key and intiger and have Identity.
//+ If we have a string unique column as a Primary key and then the entity framework will not consider it as a Primary key.
[Key]  //+ we can use this attribute to tell that this is the primary key
[Key][DatabaseGenerated(DatabaseGeneratedOption.None)]  //+ As the column is not identity and the column value cannot be autogenerated by the sQL,we can tell them by usibng this attr
//+ None, Identity and Computed. 3 options for the databasegeneratedoption
//% Composite Primary Key, If we have a composite primary key, we need to mention the order.
//* [Key][Column(Order=1)]
//* public int OrderID {get; set;}
//* [Key][Column(Order=2)]
//* public int OrderItemID { get; set;}
[Required] //+ for mking the column Non Nullable
[MaxLength(255)] //+ For mentioning the varchar charectors
[Index(isunique = true)] //+ For mentioning the Index
//% Mentioning index for 2 columns.
//* [Index("idxOrderId", 1)]
//* public int OrderID {get; set;}
//* [Index("idxOrderItemId", 2)]
//* public int OrderItemID { get; set;}
//% ForeignKey, If we do not mention a seperate foriegn key and if we mention the foriegn key model inside the parent model, It will create a foriegn key with a underscore.
//+ To avoid it and take manual control, we can mention the foriegn key property and we can mention the related model in the attribute. or we can do the opposite.
//+ we can mention the foriegn key attribute on top of the forign model and mentioned the related property ID.
//* public class Course
//* {
//*     [ForeignKey(“Author”) ]
//*     public int AuthorId { get; set; }
//*     public Author Author { get; set; }
//* }
//% OR
//* public class Course
//* {
//*     public int AuthorId { get; set; }
//*     [ForeignKey(“AuthorId”) ]
//*     public Author Author { get; set; }
//* }

//! Fluent API
//+ we need to overwrite OnModelCreating method
//+ we can use Entity to modify a specific entity
//+ modelBuilder.Entity<Course>()
//+ we can uuse totable method to point to the table name
//* modelBuilder.Entity<Course>().ToTable("tblCourses", "Schema");
//+ For Primary key, we use has key method
//* modelBuilder.Entity<Course>().HasKey(x => x.CourseID);
//* modelBuilder.Entity<Course>().HasKey(x => new { x.CourseID, x.Description } );   //+ For Composite primary key

//% Property method can be used for mapping to a column
//* modelBuilder.Entity<Course>().Property(t => t.AuthorID).HasColumnName("author_ID");     //hasProperty use to map the property name with db column name.
//% .HasColumnType("varchar") for mapping the column type
//% .HasDatabaseGeneratedOption(DatabaseGeneratedOption.None) for changing the Identity
//% .IsRequiered for making it non nullable
//% .HasMaxLength(255)  for making the column max length

//! Relationships in Fluent API
//+ If there is 2 tables, type 1 and type 2. and consider type 1 as the starting point we can make type 1 as entity and we can call methods to specify
//+ the relationships. we can use HasMany() if type have many relationships with type 2. HasRequired() if type 1 have only one relation with type 2.
//+ hasOptional() for having zero or 1 relationships with type 2. and now we need to configure the reverse direction, WithMany(), WithRequired and WithOPtional().

//% One to Many (One auther can have multiple courses. and one course can have single auther)
//+ If we start this from author entity, then
//* modelBuilder.Entity<Author>()
//* .HasMany(a => a.Courses)
//* .WithRequired(a => a.Author)
//* .HasForeignKey(a => a.AuthorID);   // For mentioning the foriegn key column

//% MAny to many Relation(Course and tag)
//+ If we start from course table
//* modelBuilder.Entity<Course>()
//* .HasMany(e => e.Tags)
//* .WithMany(e => e.Courses)
//* .Map(m => m.ToTable("CoursesTag"));   // we can give proper name for the intermediary table

//% One to zero relationships(Course and caption. course can optionally have caption, caption can strictly have one course)
//* modelBuilder.Entity<Course>()
//* .HasOptional(e => e.Caption)
//* .WithRequired(e => e.Course)

//% On to one relation (Course and cover)
//+ Here course is the parent and cover is the child, we cannot have a cover without having a course.In EF, parent is called as principle and child is dependant
//+ SO here course is the principle and we need to mention that
//* modelBuilder.Entity<Course>()
//* .HasRequired(e => e.Cover)
//* .WithRequiredPrincipal(a => a.Course);
//+ we can reverse it as well, doing it opposite direction
//* modelBuilder.Entity<Cover>()
//* .HasRequired(e => e.Course)
//* .WithRequiredDependent(a => a.Cover);

//! Rearranging the fluent API
//+ we can create a class which is inheriting from EntityTypeonfiguration<Course> and we can move the methods to this class. so it wil be more cleaner
//* class CourseConfiguration : EntityTypeConfiguration<Course>
//* {
//*     public CourseConfiguration()
//*     {
//*
//*         HasMany(e => e.Tags)
//*         .WithMany(e => e.Courses)
//*         .Map(m => m.ToTable("TagCourses").MapLeftKey("Course_CourseID"));
//*     }
//* }

//! Querying data in Entity framework
//* var context = new PlutoContext();
//* List<Course> courses = context.Courses.Where(a => a.Name.Contains("C#")).OrderBy(c=>c.Name).ToList();
//* List<Course> courses = context.Courses.Where(a => a.Level == 1).OrderBy(c=>c.Name).ThenBy(c=> c.Level).ToList();  // OrderBy and ThenBY // orderByDescending()
//*%.select() can be used to project the output to a specific object
//* var courseDetails = context.Courses.Where(a => a.Level == 1).OrderBy(c => c.Name).ThenBy(c => c.Level)
//* .Select(x => new { Name = x.Name, Description = x.Description}).ToList();
//* foreach (var course in courseDetails)
//* {
//* Console.WriteLine(course.Name);
//* }

//% for selecting tags which can be many relations. it will end up list of lists
//* var courseDetails = context.Courses.Where(a => a.Level == 1).OrderBy(c => c.Name).ThenBy(c => c.Level)
//* .Select(x => x.Tags);
//*
//* foreach (var course in courseDetails)
//* {
//* foreach (var item in course)
//* {
//*     Console.WriteLine(item.Name);
//* }
//* }
//% By using SelectMany we can change it
//* var tags = context.Courses.Where(a => a.Level == 1).OrderBy(c => c.Name).ThenBy(c => c.Level)
//* .SelectMany(x => x.Tags);
//*
//* foreach (var item in tags)
//* {
//* Console.WriteLine(item.Name);
//* }

//% Distinct() for making the common values to one

//% Grouping
//+ create list of list. key in the first list have the grouping key value
//* var groups = context.Courses.GroupBy(x => x.Level);
//* foreach (var groip in groups)
//* {
//*     Console.WriteLine("Level:" + groip.Key + "\n");
//*     foreach (Course course in groip)
//*     {
//*         Console.WriteLine("\t"+ course.Name);
//*     }
//* }

//% Inner Join, Group Join and cross join
//+ Inner join is used to relate models if there is no predefined relationships mentioned. If there is already a foriegn key, we dont need to use inner join. if there
//+ is no foriegn key but we still ned to join the tables then weuse inner join
var result = context.Courses.Join(context.Authors, x => x.AuthorId, y => y.Id, (course, author) => new
    {
        CourseName = course.Name,
        Author = author.Name
    });
//+ mention the second table. then the first tableID then the second table id and the output object.

//+ GroupJoin is useful when we need aleft join and the join to find the count, for one to many relations
//+ we join the two tables when authors have multiple couurses and then we mention what we need to return.
var result = context.Authors.GroupJoin(context.Courses, x => x.Id, y => y.AuthorId, (author, courses) => new
    {
        Author = author,
        Count= courses.Count()
    });

//+ Cross join is used by selectmany method
var result = context.Courses.SelectMany(context.Authors, (course, author) => new
    {
        AuthorName = author.Name,
        CourseName = course.Name
    });

//! Partitioning
//% Skip and take
var result = context.Courses.Skip(10).Take(25);

//! Element operators
//% .First() for fetching the first item in the list, we can pass input condition as well. throws exception if the list is null
//% FirstOrDefault returns null if the list is null
//% Last() for getting the last item in the list, LastOrDefault()
//% Single()and SingleOrDefault for getting the single item.
//% All() to check if all of the items satisfies a criteria
//% Any() if any item satisfies the condition
//% Count() for count, Max() for maximum value, Min() for minimum value, Average() for average.

//! Call to databse will not happen when we create the query, It happens when we loop it or call ToList or .first() or  any other methods
//% calling custom properties before the query execution can cause exceptions. we can use it after fetching the records. it can cause performance issues.

//! IQueryable
//+ IQueryable is an inteface inherit from IEnumerable. IQueryable allows the query to be extended and dont need a immediate execution. Ienumerable needs an immediate execution.
//+ IQueryable input parameter is an expression. but IEnumerable have a func deligate

//! Lazy loading
//* var courses = context.Courses.Single(c => c.Id == 2);
//* foreach (var item in courses.Tags)
//* {
//*     Console.WriteLine(item.Name);
//* }
//+ here when we execute first command, tags will not be fetched. when we try to get Tags in foreach, then EF will make another call to get the Tags. this is called lazy loading.
//+ Everything will not be loaded by default. for this to happen, we need to mention the specific related object as virtual. if we already got the object, we can continue using it
//+ even if we tryto get the Tags in watch window, it will make a call to fetch the tags. so it can be misleading
//* this.Configuration.LazyLoadingEnabled = false;   we can add this in the context constructor to turn off the lazy loading.

//! N+1 problem
//* var courses = context.Courses.ToList();
//* foreach (var item in courses)
//* {
//*     Console.WriteLine("{0},{1}", item.Name, item.Author.Name);
//* }

//+ here, first we hit the DB and get the courses, and in each time iterates, we hit the DB for getting the Author. This is unnecessay calls to DB. we are hitting the 
//+ DB for every number or courses.we are getting authors for each courses at a time. but if the autor already fetched for specific ID, it will not make another call.

//! .Include()
//+ we can fix this problem by using eager loading. we can use .Include to load the table in the first execution itself. it will join the table and get the data in one round trip
//+ Better to use with lambda expression.
//+ this can leadd toperformance issue as well. we are fetching everything and loading to memory

//! Explicit loading
//+ we can use explicit loading to make less comlexicity of Include. we load the items when we need it explicitly
//* var author = context.Authors.Single(a => a.Id == 1);
//* context.Courses.Where(c => c.AuthorId == author.Id).Load();
//* var authorIDs = author.Select(x => x.Id);
//* context.Courses.Where(c => authorIDs.Contains(c.Id)).Load();    //we can use contains() for using IN in SQL.

//! updating DB
//% for updating the DB we can use .SaveChanges() method.
